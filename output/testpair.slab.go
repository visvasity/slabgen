// Code generated by github.com/visvasity/slabgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	input "github.com/visvasity/slabgen/input"
	"github.com/visvasity/slabgen/slabs"
	"github.com/visvasity/slabgen/slabutil"
)

// Reader type defines accessor methods for read-only access.
type TestPairReader[T slabs.Number] []byte

// Writer type extends the reader with mutable methods.
type TestPairWriter[T slabs.Number] struct{ TestPairReader[T] }

var fieldOffsetsOfTestPair slabutil.OffsetsMap

// SlabBytes returns access to the underlying byte slice.
func (v TestPairReader[T]) SlabBytes() slabs.Bytes {
	return []byte(v)
}

// Writer returns the TestPair writer for read-write access to it's fields.
func (v TestPairReader[T]) Writer() TestPairWriter[T] {
	return TestPairWriter[T]{v}
}

// Reader returns the TestPair reader with read-only access to it's fields.
func (v TestPairWriter[T]) Reader() TestPairReader[T] {
	return v.TestPairReader
}

// IsZero returns true if all underlying bytes are zero.
func (v TestPairReader[T]) IsZero() bool {
	var structSizeOfTestPair = slabutil.SizeFor[input.TestPair[T]]()
	return slabutil.IsZero(v[:structSizeOfTestPair])
}

// SetZero sets all underlying bytes to zero.
func (v TestPairWriter[T]) SetZero() {
	var structSizeOfTestPair = slabutil.SizeFor[input.TestPair[T]]()
	slabutil.SetZero(v.SlabBytes()[:structSizeOfTestPair])
}

func (v TestPairReader[T]) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "First=%d", v.First())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "Second=%d", v.Second())
	return sb.String()
}

func (v TestPairReader[T]) CopyTo(x *input.TestPair[T]) {
	x.First = v.First()
	x.Second = v.Second()
}

func (v TestPairWriter[T]) CopyFrom(x *input.TestPair[T]) {
	v.SetFirst(x.First)
	v.SetSecond(x.Second)
}

func (v TestPairReader[T]) First() T {
	var fieldOffsetsOfTestPair = slabutil.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[0]
	return slabutil.NumberAt[T](v.SlabBytes(), offset)
}

func (v TestPairWriter[T]) SetFirst(x T) {
	var fieldOffsetsOfTestPair = slabutil.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[0]
	slabutil.SetNumberAt[T](v.SlabBytes(), offset, x)
}

func (v TestPairReader[T]) Second() T {
	var fieldOffsetsOfTestPair = slabutil.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[1]
	return slabutil.NumberAt[T](v.SlabBytes(), offset)
}

func (v TestPairWriter[T]) SetSecond(x T) {
	var fieldOffsetsOfTestPair = slabutil.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[1]
	slabutil.SetNumberAt[T](v.SlabBytes(), offset, x)
}

// NewTestPairReader creates a zero-initialized TestPair. Returns nil if input block size is too small.
func NewTestPair[T slabs.Number](block []byte) TestPairReader[T] {
	var structSizeOfTestPair = slabutil.SizeFor[input.TestPair[T]]()
	size := len(block)
	if size < structSizeOfTestPair {
		return nil
	}
	slabutil.SetZero(block)
	v := TestPairReader[T](block)
	return v
}

// OpenTestPairReader parses and prepares an existing TestPair for read/write access.
func OpenTestPair[T slabs.Number](block []byte) (TestPairReader[T], error) {
	var structSizeOfTestPair = slabutil.SizeFor[input.TestPair[T]]()
	size := len(block)
	if size < structSizeOfTestPair {
		return nil, fmt.Errorf("input size is too small")
	}
	v := TestPairReader[T](block)
	return v, nil
}
