// Code generated by github.com/visvasity/slabgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	input "github.com/visvasity/slabgen/input"
	"github.com/visvasity/slabgen/slabs"
	"github.com/visvasity/slabgen/slabutil"
)

// Reader type defines accessor methods for read-only access.
type TestFinalSliceKind8Reader[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]] []byte

// Writer type extends the reader with mutable methods.
type TestFinalSliceKind8Writer[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]] struct {
	TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]
}

var fieldOffsetsOfTestFinalSliceKind8 slabutil.OffsetsMap

// SlabBytes returns access to the underlying byte slice.
func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) SlabBytes() slabs.Bytes {
	return []byte(v)
}

// Writer returns the TestFinalSliceKind8 writer for read-write access to it's fields.
func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) Writer() TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer] {
	return TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]{v}
}

// Reader returns the TestFinalSliceKind8 reader with read-only access to it's fields.
func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) Reader() TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer] {
	return v.TestFinalSliceKind8Reader
}

// IsZero returns true if all underlying bytes are zero.
func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) IsZero() bool {
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	return slabutil.IsZero(v[:structSizeOfTestFinalSliceKind8])
}

// SetZero sets all underlying bytes to zero.
func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) SetZero() {
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	slabutil.SetZero(v.SlabBytes()[:structSizeOfTestFinalSliceKind8])
}

func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "FinalSlice=[:%d:%d]{", v.FinalSliceLen(), v.FinalSliceCap())
	for i := 0; i < v.FinalSliceLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.FinalSliceItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.FinalSliceItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) CopyTo(x *input.TestFinalSliceKind8[T1, S1]) {
	x.FinalSlice = make([]input.TestMixedPair[uint16, S1], v.FinalSliceLen())
	for i := 0; i < v.FinalSliceLen(); i++ {
		v.FinalSliceItemAt(i).CopyTo(&x.FinalSlice[i])
	}
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) CopyFrom(x *input.TestFinalSliceKind8[T1, S1]) {
	v.ResizeFinalSlice(len(x.FinalSlice))
	for i := 0; i < len(x.FinalSlice); i++ {
		v.FinalSliceItemAt(i).Writer().CopyFrom(&x.FinalSlice[i])
	}
}

// TestFinalSliceKind8SliceFieldCap returns the slice field capacity for the given underlying byte slice size.
func TestFinalSliceKind8SliceFieldCap[T1 slabs.Number, S1 slabs.Struct](nbytes int) int {
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	var sliceElemSizeOfTestFinalSliceKind8 = slabutil.ElemSizeFor[input.TestMixedPair[uint16, S1]]()
	// TODO: We should also add the required alignment offset to the struct-size.
	return (nbytes - structSizeOfTestFinalSliceKind8) / sliceElemSizeOfTestFinalSliceKind8
}

// FinalSliceLen method returns number of elements in the slice field.
func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) FinalSliceLen() int {
	var fieldOffsetsOfTestFinalSliceKind8 = slabutil.OffsetsFor[input.TestFinalSliceKind8[T1, S1]](&fieldOffsetsOfTestFinalSliceKind8)
	var offset = fieldOffsetsOfTestFinalSliceKind8[0] + slabutil.OffsetOfSliceLen
	return slabutil.IntAt(v.SlabBytes(), offset)
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) internalSetFinalSliceLen(x int) {
	var fieldOffsetsOfTestFinalSliceKind8 = slabutil.OffsetsFor[input.TestFinalSliceKind8[T1, S1]](&fieldOffsetsOfTestFinalSliceKind8)
	var offset = fieldOffsetsOfTestFinalSliceKind8[0] + slabutil.OffsetOfSliceLen
	slabutil.SetIntAt(v.SlabBytes(), offset, x)
}

// FinalSliceCap method returns maximum number of elements for the slice field.
func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) FinalSliceCap() int {
	var fieldOffsetsOfTestFinalSliceKind8 = slabutil.OffsetsFor[input.TestFinalSliceKind8[T1, S1]](&fieldOffsetsOfTestFinalSliceKind8)
	var offset = fieldOffsetsOfTestFinalSliceKind8[0] + slabutil.OffsetOfSliceCap
	return slabutil.IntAt(v.SlabBytes(), offset)
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) internalSetFinalSliceCap(x int) {
	var fieldOffsetsOfTestFinalSliceKind8 = slabutil.OffsetsFor[input.TestFinalSliceKind8[T1, S1]](&fieldOffsetsOfTestFinalSliceKind8)
	var offset = fieldOffsetsOfTestFinalSliceKind8[0] + slabutil.OffsetOfSliceCap
	slabutil.SetIntAt(v.SlabBytes(), offset, x)
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) ResizeFinalSlice(size int) int {
	if cap := v.FinalSliceCap(); size > cap {
		size = cap
	}
	n := v.FinalSliceLen()
	if size == n {
		return size
	}
	if size < n {
		v.DeleteFinalSliceItems(size, n)
		return size
	}
	v.internalSetFinalSliceLen(size)
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]input.TestMixedPair[uint16, S1]]()
	var begin = structSizeOfTestFinalSliceKind8 + n*elemSize
	var end = structSizeOfTestFinalSliceKind8 + size*elemSize
	slabutil.SetZero(v.SlabBytes()[begin:end])
	return size
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) DeleteFinalSliceItems(i, j int) {
	n := v.FinalSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("first slice index %d is out of range [0:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	if j < 0 || j >= n {
		panic(fmt.Sprintf("second slice index %d is out of range [0:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	if j < i {
		panic(fmt.Sprintf("invalid slice indices %d < %d", j, i))
	}
	if i == j {
		return
	}
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]input.TestMixedPair[uint16, S1]]()

	ioff := structSizeOfTestFinalSliceKind8 + i*elemSize
	joff := structSizeOfTestFinalSliceKind8 + j*elemSize
	end := structSizeOfTestFinalSliceKind8 + n*elemSize

	copy(v.SlabBytes()[ioff:end], v.SlabBytes()[joff:end])
	slabutil.SetZero(v.SlabBytes()[end-(joff-ioff) : end])
	v.internalSetFinalSliceLen(n - (j - i))
}

func (v TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer]) FinalSliceItemAt(i int) TestMixedPairReader[uint16, S1, S1Reader, S1Writer] {
	if i < 0 || i >= v.FinalSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]input.TestMixedPair[uint16, S1]]()
	var offset = structSizeOfTestFinalSliceKind8 + i*elemSize
	return TestMixedPairReader[uint16, S1, S1Reader, S1Writer](v.SlabBytes()[offset:])
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) SetFinalSliceItemAt(i int, x TestMixedPairReader[uint16, S1, S1Reader, S1Writer]) {
	if i < 0 || i >= v.FinalSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]input.TestMixedPair[uint16, S1]]()
	var offset = structSizeOfTestFinalSliceKind8 + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x.SlabBytes()[:elemSize])
}

func (v TestFinalSliceKind8Writer[T1, S1, S1Reader, S1Writer]) AppendFinalSliceItem(x TestMixedPairReader[uint16, S1, S1Reader, S1Writer]) {
	n := v.FinalSliceLen()
	if n == v.FinalSliceCap() {
		panic(fmt.Sprintf("append to slice overflows the maximum capacity [::%d]", v.FinalSliceCap()))
	}
	v.internalSetFinalSliceLen(n + 1)
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]input.TestMixedPair[uint16, S1]]()
	var offset = structSizeOfTestFinalSliceKind8 + n*elemSize
	if x == nil {
		slabutil.SetZero(v.SlabBytes()[offset : offset+elemSize])
	} else {
		copy(v.SlabBytes()[offset:offset+elemSize], x.SlabBytes()[:elemSize])
	}
}

// NewTestFinalSliceKind8Reader creates a zero-initialized TestFinalSliceKind8. Returns nil if input block size is too small.
func NewTestFinalSliceKind8[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]](block []byte) TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer] {
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	size := len(block)
	if size < structSizeOfTestFinalSliceKind8 {
		return nil
	}
	slabutil.SetZero(block)
	v := TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer](block)
	// TestFinalSliceKind8 type has a slice field; we must set a cap on it.
	n := TestFinalSliceKind8SliceFieldCap[T1, S1](size)
	v.Writer().internalSetFinalSliceCap(n)
	return v
}

// OpenTestFinalSliceKind8Reader parses and prepares an existing TestFinalSliceKind8 for read/write access.
func OpenTestFinalSliceKind8[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]](block []byte) (TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer], error) {
	var structSizeOfTestFinalSliceKind8 = slabutil.SizeFor[input.TestFinalSliceKind8[T1, S1]]()
	size := len(block)
	if size < structSizeOfTestFinalSliceKind8 {
		return nil, fmt.Errorf("input size is too small")
	}
	v := TestFinalSliceKind8Reader[T1, S1, S1Reader, S1Writer](block)
	// TestFinalSliceKind8 type has a slice field; validate it's len and cap.
	n := TestFinalSliceKind8SliceFieldCap[T1, S1](size)
	if x := v.FinalSliceCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.FinalSliceLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
