// Code generated by github.com/visvasity/blockgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	"github.com/visvasity/blockgen/blockgen"
	input "github.com/visvasity/blockgen/input"
)

// Reader type defines accessor methods for read-only access.
type TestMixedPairReader[T blockgen.Number, S blockgen.Struct, SReader blockgen.Reader[S, SWriter], SWriter blockgen.Writer[S, SReader]] blockgen.BlockBytes

// Writer type extends the reader with mutable methods.
type TestMixedPairWriter[T blockgen.Number, S blockgen.Struct, SReader blockgen.Reader[S, SWriter], SWriter blockgen.Writer[S, SReader]] struct {
	TestMixedPairReader[T, S, SReader, SWriter]
}

var fieldOffsetsOfTestMixedPair blockgen.OffsetsMap

// BlockBytes returns access to the underlying byte slice.
func (v TestMixedPairReader[T, S, SReader, SWriter]) BlockBytes() blockgen.BlockBytes {
	return blockgen.BlockBytes(v)
}

// Writer returns the TestMixedPair writer for read-write access to it's fields.
func (v TestMixedPairReader[T, S, SReader, SWriter]) Writer() TestMixedPairWriter[T, S, SReader, SWriter] {
	return TestMixedPairWriter[T, S, SReader, SWriter]{v}
}

// Reader returns the TestMixedPair reader with read-only access to it's fields.
func (v TestMixedPairWriter[T, S, SReader, SWriter]) Reader() TestMixedPairReader[T, S, SReader, SWriter] {
	return v.TestMixedPairReader
}

// IsZero returns true if all underlying bytes are zero.
func (v TestMixedPairReader[T, S, SReader, SWriter]) IsZero() bool {
	var structSizeOfTestMixedPair = blockgen.SizeFor[input.TestMixedPair[T, S]]()
	return blockgen.IsZero(v[:structSizeOfTestMixedPair])
}

// SetZero sets all underlying bytes to zero.
func (v TestMixedPairWriter[T, S, SReader, SWriter]) SetZero() {
	var structSizeOfTestMixedPair = blockgen.SizeFor[input.TestMixedPair[T, S]]()
	blockgen.SetZero(v.BlockBytes()[:structSizeOfTestMixedPair])
}

func (v TestMixedPairReader[T, S, SReader, SWriter]) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "Number=%d", v.Number())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "Struct={%v}", v.Struct())
	return sb.String()
}

func (v TestMixedPairReader[T, S, SReader, SWriter]) CopyTo(x *input.TestMixedPair[T, S]) {
	x.Number = v.Number()
	v.Struct().CopyTo(&x.Struct)
}

func (v TestMixedPairWriter[T, S, SReader, SWriter]) CopyFrom(x *input.TestMixedPair[T, S]) {
	v.SetNumber(x.Number)
	v.Struct().Writer().CopyFrom(&x.Struct)
}

func (v TestMixedPairReader[T, S, SReader, SWriter]) Number() T {
	var fieldOffsetsOfTestMixedPair = blockgen.OffsetsFor[input.TestMixedPair[T, S]](&fieldOffsetsOfTestMixedPair)
	var offset = fieldOffsetsOfTestMixedPair[0]
	return blockgen.NumberAt[T](v.BlockBytes(), offset)
}

func (v TestMixedPairWriter[T, S, SReader, SWriter]) SetNumber(x T) {
	var fieldOffsetsOfTestMixedPair = blockgen.OffsetsFor[input.TestMixedPair[T, S]](&fieldOffsetsOfTestMixedPair)
	var offset = fieldOffsetsOfTestMixedPair[0]
	blockgen.SetNumberAt[T](v.BlockBytes(), offset, x)
}

func (v TestMixedPairReader[T, S, SReader, SWriter]) Struct() SReader {
	var fieldOffsetsOfTestMixedPair = blockgen.OffsetsFor[input.TestMixedPair[T, S]](&fieldOffsetsOfTestMixedPair)
	var offset = fieldOffsetsOfTestMixedPair[1]
	return SReader(v.BlockBytes()[offset:])
}

// NewTestMixedPairReader creates a zero-initialized TestMixedPair. Returns nil if input block size is too small.
func NewTestMixedPair[T blockgen.Number, S blockgen.Struct, SReader blockgen.Reader[S, SWriter], SWriter blockgen.Writer[S, SReader]](block []byte) TestMixedPairReader[T, S, SReader, SWriter] {
	var structSizeOfTestMixedPair = blockgen.SizeFor[input.TestMixedPair[T, S]]()
	size := len(block)
	if size < structSizeOfTestMixedPair {
		return nil
	}
	blockgen.SetZero(block)
	v := TestMixedPairReader[T, S, SReader, SWriter](block)
	return v
}

// OpenTestMixedPairReader parses and prepares an existing TestMixedPair for read/write access.
func OpenTestMixedPair[T blockgen.Number, S blockgen.Struct, SReader blockgen.Reader[S, SWriter], SWriter blockgen.Writer[S, SReader]](block []byte) (TestMixedPairReader[T, S, SReader, SWriter], error) {
	var structSizeOfTestMixedPair = blockgen.SizeFor[input.TestMixedPair[T, S]]()
	size := len(block)
	if size < structSizeOfTestMixedPair {
		return nil, fmt.Errorf("input size is too small")
	}
	v := TestMixedPairReader[T, S, SReader, SWriter](block)
	return v, nil
}
