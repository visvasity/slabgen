// Code generated by github.com/visvasity/slabgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	input "github.com/visvasity/slabgen/input"
	"github.com/visvasity/slabgen/slabs"
	"github.com/visvasity/slabgen/slabutil"
)

// Reader type defines accessor methods for read-only access.
type BlockHeaderReader []byte

// Writer type extends the reader with mutable methods.
type BlockHeaderWriter struct{ BlockHeaderReader }

var structSizeOfBlockHeader = slabutil.SizeFor[input.BlockHeader]()
var fieldOffsetsOfBlockHeader = slabutil.OffsetsFor[input.BlockHeader](nil)

// SlabBytes returns access to the underlying byte slice.
func (v BlockHeaderReader) SlabBytes() slabs.Bytes {
	return []byte(v)
}

// Writer returns the BlockHeader writer for read-write access to it's fields.
func (v BlockHeaderReader) Writer() BlockHeaderWriter {
	return BlockHeaderWriter{v}
}

// Reader returns the BlockHeader reader with read-only access to it's fields.
func (v BlockHeaderWriter) Reader() BlockHeaderReader {
	return v.BlockHeaderReader
}

// IsZero returns true if all underlying bytes are zero.
func (v BlockHeaderReader) IsZero() bool {
	return slabutil.IsZero(v[:structSizeOfBlockHeader])
}

// SetZero sets all underlying bytes to zero.
func (v BlockHeaderWriter) SetZero() {
	slabutil.SetZero(v.SlabBytes()[:structSizeOfBlockHeader])
}

func (v BlockHeaderReader) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "Checksum=[%d]{", v.ChecksumLen())
	for i := 0; i < v.ChecksumLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "%d", v.ChecksumItemAt(i))
		} else {
			fmt.Fprintf(&sb, " %d", v.ChecksumItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "BlockLSN=%d", v.BlockLSN())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "BlockTypeID=%d", v.BlockTypeID())
	return sb.String()
}

func (v BlockHeaderReader) CopyTo(x *input.BlockHeader) {
	for i := 0; i < v.ChecksumLen(); i++ {
		x.Checksum[i] = v.ChecksumItemAt(i)
	}
	x.BlockLSN = v.BlockLSN()
	x.BlockTypeID = v.BlockTypeID()
}

func (v BlockHeaderWriter) CopyFrom(x *input.BlockHeader) {
	for i := 0; i < v.ChecksumLen(); i++ {
		v.SetChecksumItemAt(i, x.Checksum[i])
	}
	v.SetBlockLSN(x.BlockLSN)
	v.SetBlockTypeID(x.BlockTypeID)
}

func (v BlockHeaderReader) ChecksumLen() int {
	return int(32)
}

func (v BlockHeaderReader) ChecksumItemAt(i int) byte {
	if i < 0 || i >= v.ChecksumLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ChecksumLen()))
	}
	var elemSize = slabutil.ElemSizeFor[[1]byte]()
	var offset = fieldOffsetsOfBlockHeader[0] + i*elemSize
	return byte(v.SlabBytes().Uint8At(offset))
}

func (v BlockHeaderWriter) SetChecksumItemAt(i int, x byte) {
	if i < 0 || i >= v.ChecksumLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ChecksumLen()))
	}
	var elemSize = slabutil.ElemSizeFor[[1]byte]()
	var offset = fieldOffsetsOfBlockHeader[0] + i*elemSize
	v.SlabBytes().SetUint8At(offset, uint8(x))
}

func (v BlockHeaderReader) BlockLSN() input.LSN {
	var offset = fieldOffsetsOfBlockHeader[1]
	return input.LSN(v.SlabBytes().Int64At(offset))
}

func (v BlockHeaderWriter) SetBlockLSN(x input.LSN) {
	var offset = fieldOffsetsOfBlockHeader[1]
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v BlockHeaderReader) BlockTypeID() input.BlockType {
	var offset = fieldOffsetsOfBlockHeader[2]
	return input.BlockType(v.SlabBytes().Uint16At(offset))
}

func (v BlockHeaderWriter) SetBlockTypeID(x input.BlockType) {
	var offset = fieldOffsetsOfBlockHeader[2]
	v.SlabBytes().SetUint16At(offset, uint16(x))
}
