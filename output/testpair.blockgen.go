// Code generated by github.com/visvasity/blockgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	"github.com/visvasity/blockgen/blockgen"
	input "github.com/visvasity/blockgen/input"
)

// Reader type defines accessor methods for read-only access.
type TestPairReader[T blockgen.Number] blockgen.BlockBytes

// Writer type extends the reader with mutable methods.
type TestPairWriter[T blockgen.Number] struct{ TestPairReader[T] }

var fieldOffsetsOfTestPair blockgen.OffsetsMap

// BlockBytes returns access to the underlying byte slice.
func (v TestPairReader[T]) BlockBytes() blockgen.BlockBytes {
	return blockgen.BlockBytes(v)
}

// Writer returns the TestPair writer for read-write access to it's fields.
func (v TestPairReader[T]) Writer() TestPairWriter[T] {
	return TestPairWriter[T]{v}
}

// Reader returns the TestPair reader with read-only access to it's fields.
func (v TestPairWriter[T]) Reader() TestPairReader[T] {
	return v.TestPairReader
}

// IsZero returns true if all underlying bytes are zero.
func (v TestPairReader[T]) IsZero() bool {
	var structSizeOfTestPair = blockgen.SizeFor[input.TestPair[T]]()
	return blockgen.IsZero(v[:structSizeOfTestPair])
}

// SetZero sets all underlying bytes to zero.
func (v TestPairWriter[T]) SetZero() {
	var structSizeOfTestPair = blockgen.SizeFor[input.TestPair[T]]()
	blockgen.SetZero(v.BlockBytes()[:structSizeOfTestPair])
}

func (v TestPairReader[T]) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "First=%d", v.First())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "Second=%d", v.Second())
	return sb.String()
}

func (v TestPairReader[T]) CopyTo(x *input.TestPair[T]) {
	x.First = v.First()
	x.Second = v.Second()
}

func (v TestPairWriter[T]) CopyFrom(x *input.TestPair[T]) {
	v.SetFirst(x.First)
	v.SetSecond(x.Second)
}

func (v TestPairReader[T]) First() T {
	var fieldOffsetsOfTestPair = blockgen.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[0]
	return blockgen.NumberAt[T](v.BlockBytes(), offset)
}

func (v TestPairWriter[T]) SetFirst(x T) {
	var fieldOffsetsOfTestPair = blockgen.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[0]
	blockgen.SetNumberAt[T](v.BlockBytes(), offset, x)
}

func (v TestPairReader[T]) Second() T {
	var fieldOffsetsOfTestPair = blockgen.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[1]
	return blockgen.NumberAt[T](v.BlockBytes(), offset)
}

func (v TestPairWriter[T]) SetSecond(x T) {
	var fieldOffsetsOfTestPair = blockgen.OffsetsFor[input.TestPair[T]](&fieldOffsetsOfTestPair)
	var offset = fieldOffsetsOfTestPair[1]
	blockgen.SetNumberAt[T](v.BlockBytes(), offset, x)
}

// NewTestPairReader creates a zero-initialized TestPair. Returns nil if input block size is too small.
func NewTestPair[T blockgen.Number](block []byte) TestPairReader[T] {
	var structSizeOfTestPair = blockgen.SizeFor[input.TestPair[T]]()
	size := len(block)
	if size < structSizeOfTestPair {
		return nil
	}
	blockgen.SetZero(block)
	v := TestPairReader[T](block)
	return v
}

// OpenTestPairReader parses and prepares an existing TestPair for read/write access.
func OpenTestPair[T blockgen.Number](block []byte) (TestPairReader[T], error) {
	var structSizeOfTestPair = blockgen.SizeFor[input.TestPair[T]]()
	size := len(block)
	if size < structSizeOfTestPair {
		return nil, fmt.Errorf("input size is too small")
	}
	v := TestPairReader[T](block)
	return v, nil
}
