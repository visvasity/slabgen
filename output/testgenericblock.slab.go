// Code generated by github.com/visvasity/slabgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	input "github.com/visvasity/slabgen/input"
	"github.com/visvasity/slabgen/slabs"
	"github.com/visvasity/slabgen/slabutil"
)

// Reader type defines accessor methods for read-only access.
type TestGenericBlockReader[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]] []byte

// Writer type extends the reader with mutable methods.
type TestGenericBlockWriter[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]] struct {
	TestGenericBlockReader[T1, S1, S1Reader, S1Writer]
}

var fieldOffsetsOfTestGenericBlock slabutil.OffsetsMap

// SlabBytes returns access to the underlying byte slice.
func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) SlabBytes() slabs.Bytes {
	return []byte(v)
}

// Writer returns the TestGenericBlock writer for read-write access to it's fields.
func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) Writer() TestGenericBlockWriter[T1, S1, S1Reader, S1Writer] {
	return TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]{v}
}

// Reader returns the TestGenericBlock reader with read-only access to it's fields.
func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) Reader() TestGenericBlockReader[T1, S1, S1Reader, S1Writer] {
	return v.TestGenericBlockReader
}

// IsZero returns true if all underlying bytes are zero.
func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) IsZero() bool {
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	return slabutil.IsZero(v[:structSizeOfTestGenericBlock])
}

// SetZero sets all underlying bytes to zero.
func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetZero() {
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	slabutil.SetZero(v.SlabBytes()[:structSizeOfTestGenericBlock])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "Basic=%d", v.Basic())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "NamedBasic=%d", v.NamedBasic())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "MultiLevelNamedBasic=%d", v.MultiLevelNamedBasic())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "BasicAlias=%d", v.BasicAlias())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "BasicTypeParam=%d", v.BasicTypeParam())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "NamedStruct={%v}", v.NamedStruct())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "StructTypeParam={%v}", v.StructTypeParam())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "GenericStruct={%v}", v.GenericStruct())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "GenericMixedStruct={%v}", v.GenericMixedStruct())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "GenericStructTypeParam={%v}", v.GenericStructTypeParam())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfBasic=[%d]{", v.ArrayOfBasicLen())
	for i := 0; i < v.ArrayOfBasicLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "%d", v.ArrayOfBasicItemAt(i))
		} else {
			fmt.Fprintf(&sb, " %d", v.ArrayOfBasicItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfNamedBasic=[%d]{", v.ArrayOfNamedBasicLen())
	for i := 0; i < v.ArrayOfNamedBasicLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "%d", v.ArrayOfNamedBasicItemAt(i))
		} else {
			fmt.Fprintf(&sb, " %d", v.ArrayOfNamedBasicItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfMultiLevelNamedBasic=[%d]{", v.ArrayOfMultiLevelNamedBasicLen())
	for i := 0; i < v.ArrayOfMultiLevelNamedBasicLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "%d", v.ArrayOfMultiLevelNamedBasicItemAt(i))
		} else {
			fmt.Fprintf(&sb, " %d", v.ArrayOfMultiLevelNamedBasicItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfBasicTypeParam=[%d]{", v.ArrayOfBasicTypeParamLen())
	for i := 0; i < v.ArrayOfBasicTypeParamLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "%d", v.ArrayOfBasicTypeParamItemAt(i))
		} else {
			fmt.Fprintf(&sb, " %d", v.ArrayOfBasicTypeParamItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfBasicStruct=[%d]{", v.ArrayOfBasicStructLen())
	for i := 0; i < v.ArrayOfBasicStructLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ArrayOfBasicStructItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ArrayOfBasicStructItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfStructTypeParam=[%d]{", v.ArrayOfStructTypeParamLen())
	for i := 0; i < v.ArrayOfStructTypeParamLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ArrayOfStructTypeParamItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ArrayOfStructTypeParamItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfGenericStruct=[%d]{", v.ArrayOfGenericStructLen())
	for i := 0; i < v.ArrayOfGenericStructLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ArrayOfGenericStructItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ArrayOfGenericStructItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfGenericStructTypeParam=[%d]{", v.ArrayOfGenericStructTypeParamLen())
	for i := 0; i < v.ArrayOfGenericStructTypeParamLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ArrayOfGenericStructTypeParamItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ArrayOfGenericStructTypeParamItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ArrayOfGenericStructMixedTypeParam=[%d]{", v.ArrayOfGenericStructMixedTypeParamLen())
	for i := 0; i < v.ArrayOfGenericStructMixedTypeParamLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ArrayOfGenericStructMixedTypeParamItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ArrayOfGenericStructMixedTypeParamItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FinalSlice=[:%d:%d]{", v.FinalSliceLen(), v.FinalSliceCap())
	for i := 0; i < v.FinalSliceLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.FinalSliceItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.FinalSliceItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) CopyTo(x *input.TestGenericBlock[T1, S1]) {
	x.Basic = v.Basic()
	x.NamedBasic = v.NamedBasic()
	x.MultiLevelNamedBasic = v.MultiLevelNamedBasic()
	x.BasicAlias = v.BasicAlias()
	x.BasicTypeParam = v.BasicTypeParam()
	v.NamedStruct().CopyTo(&x.NamedStruct)
	v.StructTypeParam().CopyTo(&x.StructTypeParam)
	v.GenericStruct().CopyTo(&x.GenericStruct)
	v.GenericMixedStruct().CopyTo(&x.GenericMixedStruct)
	v.GenericStructTypeParam().CopyTo(&x.GenericStructTypeParam)
	for i := 0; i < v.ArrayOfBasicLen(); i++ {
		x.ArrayOfBasic[i] = v.ArrayOfBasicItemAt(i)
	}
	for i := 0; i < v.ArrayOfNamedBasicLen(); i++ {
		x.ArrayOfNamedBasic[i] = v.ArrayOfNamedBasicItemAt(i)
	}
	for i := 0; i < v.ArrayOfMultiLevelNamedBasicLen(); i++ {
		x.ArrayOfMultiLevelNamedBasic[i] = v.ArrayOfMultiLevelNamedBasicItemAt(i)
	}
	for i := 0; i < v.ArrayOfBasicTypeParamLen(); i++ {
		x.ArrayOfBasicTypeParam[i] = v.ArrayOfBasicTypeParamItemAt(i)
	}
	for i := 0; i < v.ArrayOfBasicStructLen(); i++ {
		v.ArrayOfBasicStructItemAt(i).CopyTo(&x.ArrayOfBasicStruct[i])
	}
	for i := 0; i < v.ArrayOfStructTypeParamLen(); i++ {
		v.ArrayOfStructTypeParamItemAt(i).CopyTo(&x.ArrayOfStructTypeParam[i])
	}
	for i := 0; i < v.ArrayOfGenericStructLen(); i++ {
		v.ArrayOfGenericStructItemAt(i).CopyTo(&x.ArrayOfGenericStruct[i])
	}
	for i := 0; i < v.ArrayOfGenericStructTypeParamLen(); i++ {
		v.ArrayOfGenericStructTypeParamItemAt(i).CopyTo(&x.ArrayOfGenericStructTypeParam[i])
	}
	for i := 0; i < v.ArrayOfGenericStructMixedTypeParamLen(); i++ {
		v.ArrayOfGenericStructMixedTypeParamItemAt(i).CopyTo(&x.ArrayOfGenericStructMixedTypeParam[i])
	}
	x.FinalSlice = make([]S1, v.FinalSliceLen())
	for i := 0; i < v.FinalSliceLen(); i++ {
		v.FinalSliceItemAt(i).CopyTo(&x.FinalSlice[i])
	}
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) CopyFrom(x *input.TestGenericBlock[T1, S1]) {
	v.SetBasic(x.Basic)
	v.SetNamedBasic(x.NamedBasic)
	v.SetMultiLevelNamedBasic(x.MultiLevelNamedBasic)
	v.SetBasicAlias(x.BasicAlias)
	v.SetBasicTypeParam(x.BasicTypeParam)
	v.NamedStruct().Writer().CopyFrom(&x.NamedStruct)
	v.StructTypeParam().Writer().CopyFrom(&x.StructTypeParam)
	v.GenericStruct().Writer().CopyFrom(&x.GenericStruct)
	v.GenericMixedStruct().Writer().CopyFrom(&x.GenericMixedStruct)
	v.GenericStructTypeParam().Writer().CopyFrom(&x.GenericStructTypeParam)
	for i := 0; i < v.ArrayOfBasicLen(); i++ {
		v.SetArrayOfBasicItemAt(i, x.ArrayOfBasic[i])
	}
	for i := 0; i < v.ArrayOfNamedBasicLen(); i++ {
		v.SetArrayOfNamedBasicItemAt(i, x.ArrayOfNamedBasic[i])
	}
	for i := 0; i < v.ArrayOfMultiLevelNamedBasicLen(); i++ {
		v.SetArrayOfMultiLevelNamedBasicItemAt(i, x.ArrayOfMultiLevelNamedBasic[i])
	}
	for i := 0; i < v.ArrayOfBasicTypeParamLen(); i++ {
		v.SetArrayOfBasicTypeParamItemAt(i, x.ArrayOfBasicTypeParam[i])
	}
	for i := 0; i < v.ArrayOfBasicStructLen(); i++ {
		v.ArrayOfBasicStructItemAt(i).Writer().CopyFrom(&x.ArrayOfBasicStruct[i])
	}
	for i := 0; i < v.ArrayOfStructTypeParamLen(); i++ {
		v.ArrayOfStructTypeParamItemAt(i).Writer().CopyFrom(&x.ArrayOfStructTypeParam[i])
	}
	for i := 0; i < v.ArrayOfGenericStructLen(); i++ {
		v.ArrayOfGenericStructItemAt(i).Writer().CopyFrom(&x.ArrayOfGenericStruct[i])
	}
	for i := 0; i < v.ArrayOfGenericStructTypeParamLen(); i++ {
		v.ArrayOfGenericStructTypeParamItemAt(i).Writer().CopyFrom(&x.ArrayOfGenericStructTypeParam[i])
	}
	for i := 0; i < v.ArrayOfGenericStructMixedTypeParamLen(); i++ {
		v.ArrayOfGenericStructMixedTypeParamItemAt(i).Writer().CopyFrom(&x.ArrayOfGenericStructMixedTypeParam[i])
	}
	v.ResizeFinalSlice(len(x.FinalSlice))
	for i := 0; i < len(x.FinalSlice); i++ {
		v.FinalSliceItemAt(i).Writer().CopyFrom(&x.FinalSlice[i])
	}
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) Basic() int64 {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[0]
	return int64(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetBasic(x int64) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[0]
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) NamedBasic() input.TestNamedInt64 {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[1]
	return input.TestNamedInt64(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetNamedBasic(x input.TestNamedInt64) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[1]
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) MultiLevelNamedBasic() input.TestMultiLevelNamedInt64 {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[2]
	return input.TestMultiLevelNamedInt64(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetMultiLevelNamedBasic(x input.TestMultiLevelNamedInt64) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[2]
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) BasicAlias() input.TestInt64Alias {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[3]
	return input.TestInt64Alias(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetBasicAlias(x input.TestInt64Alias) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[3]
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) BasicTypeParam() T1 {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[4]
	return slabutil.NumberAt[T1](v.SlabBytes(), offset)
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetBasicTypeParam(x T1) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[4]
	slabutil.SetNumberAt[T1](v.SlabBytes(), offset, x)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) NamedStruct() TestStructReader {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[5]
	return TestStructReader(v.SlabBytes()[offset:])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) StructTypeParam() S1Reader {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[6]
	return S1Reader(v.SlabBytes()[offset:])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) GenericStruct() TestPairReader[int32] {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[7]
	return TestPairReader[int32](v.SlabBytes()[offset:])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) GenericMixedStruct() TestMixedPairReader[int32, S1, S1Reader, S1Writer] {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[8]
	return TestMixedPairReader[int32, S1, S1Reader, S1Writer](v.SlabBytes()[offset:])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) GenericStructTypeParam() TestPairReader[T1] {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[9]
	return TestPairReader[T1](v.SlabBytes()[offset:])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfBasicLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfBasicItemAt(i int) int64 {
	if i < 0 || i >= v.ArrayOfBasicLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfBasicLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]int64]()
	var offset = fieldOffsetsOfTestGenericBlock[10] + i*elemSize
	return int64(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfBasicItemAt(i int, x int64) {
	if i < 0 || i >= v.ArrayOfBasicLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfBasicLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]int64]()
	var offset = fieldOffsetsOfTestGenericBlock[10] + i*elemSize
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfNamedBasicLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfNamedBasicItemAt(i int) input.TestNamedInt64 {
	if i < 0 || i >= v.ArrayOfNamedBasicLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfNamedBasicLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]input.TestNamedInt64]()
	var offset = fieldOffsetsOfTestGenericBlock[11] + i*elemSize
	return input.TestNamedInt64(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfNamedBasicItemAt(i int, x input.TestNamedInt64) {
	if i < 0 || i >= v.ArrayOfNamedBasicLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfNamedBasicLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]input.TestNamedInt64]()
	var offset = fieldOffsetsOfTestGenericBlock[11] + i*elemSize
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfMultiLevelNamedBasicLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfMultiLevelNamedBasicItemAt(i int) input.TestMultiLevelNamedInt64 {
	if i < 0 || i >= v.ArrayOfMultiLevelNamedBasicLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfMultiLevelNamedBasicLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]input.TestMultiLevelNamedInt64]()
	var offset = fieldOffsetsOfTestGenericBlock[12] + i*elemSize
	return input.TestMultiLevelNamedInt64(v.SlabBytes().Int64At(offset))
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfMultiLevelNamedBasicItemAt(i int, x input.TestMultiLevelNamedInt64) {
	if i < 0 || i >= v.ArrayOfMultiLevelNamedBasicLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfMultiLevelNamedBasicLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]input.TestMultiLevelNamedInt64]()
	var offset = fieldOffsetsOfTestGenericBlock[12] + i*elemSize
	v.SlabBytes().SetInt64At(offset, int64(x))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfBasicTypeParamLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfBasicTypeParamItemAt(i int) T1 {
	if i < 0 || i >= v.ArrayOfBasicTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfBasicTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]T1]()
	var offset = fieldOffsetsOfTestGenericBlock[13] + i*elemSize
	return slabutil.NumberAt[T1](v.SlabBytes(), offset)
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfBasicTypeParamItemAt(i int, x T1) {
	if i < 0 || i >= v.ArrayOfBasicTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfBasicTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]T1]()
	var offset = fieldOffsetsOfTestGenericBlock[13] + i*elemSize
	slabutil.SetNumberAt[T1](v.SlabBytes(), offset, x)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfBasicStructLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfBasicStructItemAt(i int) TestStructReader {
	if i < 0 || i >= v.ArrayOfBasicStructLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfBasicStructLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestStructReader]()
	var offset = fieldOffsetsOfTestGenericBlock[14] + i*elemSize
	return TestStructReader(v.SlabBytes()[offset:])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfBasicStructItemAt(i int, x TestStructReader) {
	if i < 0 || i >= v.ArrayOfBasicStructLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfBasicStructLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestStructReader]()
	var offset = fieldOffsetsOfTestGenericBlock[14] + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x[:elemSize])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfStructTypeParamLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfStructTypeParamItemAt(i int) S1Reader {
	if i < 0 || i >= v.ArrayOfStructTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfStructTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]S1Reader]()
	var offset = fieldOffsetsOfTestGenericBlock[15] + i*elemSize
	return S1Reader(v.SlabBytes()[offset:])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfStructTypeParamItemAt(i int, x S1Reader) {
	if i < 0 || i >= v.ArrayOfStructTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfStructTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]S1Reader]()
	var offset = fieldOffsetsOfTestGenericBlock[15] + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x[:elemSize])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfGenericStructLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfGenericStructItemAt(i int) TestPairReader[int64] {
	if i < 0 || i >= v.ArrayOfGenericStructLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfGenericStructLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestPairReader[int64]]()
	var offset = fieldOffsetsOfTestGenericBlock[16] + i*elemSize
	return TestPairReader[int64](v.SlabBytes()[offset:])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfGenericStructItemAt(i int, x TestPairReader[int64]) {
	if i < 0 || i >= v.ArrayOfGenericStructLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfGenericStructLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestPairReader[int64]]()
	var offset = fieldOffsetsOfTestGenericBlock[16] + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x[:elemSize])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfGenericStructTypeParamLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfGenericStructTypeParamItemAt(i int) TestPairReader[T1] {
	if i < 0 || i >= v.ArrayOfGenericStructTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfGenericStructTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestPairReader[T1]]()
	var offset = fieldOffsetsOfTestGenericBlock[17] + i*elemSize
	return TestPairReader[T1](v.SlabBytes()[offset:])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfGenericStructTypeParamItemAt(i int, x TestPairReader[T1]) {
	if i < 0 || i >= v.ArrayOfGenericStructTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfGenericStructTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestPairReader[T1]]()
	var offset = fieldOffsetsOfTestGenericBlock[17] + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x[:elemSize])
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfGenericStructMixedTypeParamLen() int {
	return int(10)
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) ArrayOfGenericStructMixedTypeParamItemAt(i int) TestMixedPairReader[int16, S1, S1Reader, S1Writer] {
	if i < 0 || i >= v.ArrayOfGenericStructMixedTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfGenericStructMixedTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestMixedPairReader[int16, S1, S1Reader, S1Writer]]()
	var offset = fieldOffsetsOfTestGenericBlock[18] + i*elemSize
	return TestMixedPairReader[int16, S1, S1Reader, S1Writer](v.SlabBytes()[offset:])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetArrayOfGenericStructMixedTypeParamItemAt(i int, x TestMixedPairReader[int16, S1, S1Reader, S1Writer]) {
	if i < 0 || i >= v.ArrayOfGenericStructMixedTypeParamLen() {
		panic(fmt.Sprintf("array index %d is out of range [0:%d]", i, v.ArrayOfGenericStructMixedTypeParamLen()))
	}
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var elemSize = slabutil.ElemSizeFor[[1]TestMixedPairReader[int16, S1, S1Reader, S1Writer]]()
	var offset = fieldOffsetsOfTestGenericBlock[18] + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x[:elemSize])
}

// TestGenericBlockSliceFieldCap returns the slice field capacity for the given underlying byte slice size.
func TestGenericBlockSliceFieldCap[T1 slabs.Number, S1 slabs.Struct](nbytes int) int {
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	var sliceElemSizeOfTestGenericBlock = slabutil.ElemSizeFor[S1]()
	// TODO: We should also add the required alignment offset to the struct-size.
	return (nbytes - structSizeOfTestGenericBlock) / sliceElemSizeOfTestGenericBlock
}

// FinalSliceLen method returns number of elements in the slice field.
func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) FinalSliceLen() int {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[19] + slabutil.OffsetOfSliceLen
	return slabutil.IntAt(v.SlabBytes(), offset)
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) internalSetFinalSliceLen(x int) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[19] + slabutil.OffsetOfSliceLen
	slabutil.SetIntAt(v.SlabBytes(), offset, x)
}

// FinalSliceCap method returns maximum number of elements for the slice field.
func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) FinalSliceCap() int {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[19] + slabutil.OffsetOfSliceCap
	return slabutil.IntAt(v.SlabBytes(), offset)
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) internalSetFinalSliceCap(x int) {
	var fieldOffsetsOfTestGenericBlock = slabutil.OffsetsFor[input.TestGenericBlock[T1, S1]](&fieldOffsetsOfTestGenericBlock)
	var offset = fieldOffsetsOfTestGenericBlock[19] + slabutil.OffsetOfSliceCap
	slabutil.SetIntAt(v.SlabBytes(), offset, x)
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) ResizeFinalSlice(size int) int {
	if cap := v.FinalSliceCap(); size > cap {
		size = cap
	}
	n := v.FinalSliceLen()
	if size == n {
		return size
	}
	if size < n {
		v.DeleteFinalSliceItems(size, n)
		return size
	}
	v.internalSetFinalSliceLen(size)
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]S1]()
	var begin = structSizeOfTestGenericBlock + n*elemSize
	var end = structSizeOfTestGenericBlock + size*elemSize
	slabutil.SetZero(v.SlabBytes()[begin:end])
	return size
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) DeleteFinalSliceItems(i, j int) {
	n := v.FinalSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("first slice index %d is out of range [0:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	if j < 0 || j >= n {
		panic(fmt.Sprintf("second slice index %d is out of range [0:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	if j < i {
		panic(fmt.Sprintf("invalid slice indices %d < %d", j, i))
	}
	if i == j {
		return
	}
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]S1]()

	ioff := structSizeOfTestGenericBlock + i*elemSize
	joff := structSizeOfTestGenericBlock + j*elemSize
	end := structSizeOfTestGenericBlock + n*elemSize

	copy(v.SlabBytes()[ioff:end], v.SlabBytes()[joff:end])
	slabutil.SetZero(v.SlabBytes()[end-(joff-ioff) : end])
	v.internalSetFinalSliceLen(n - (j - i))
}

func (v TestGenericBlockReader[T1, S1, S1Reader, S1Writer]) FinalSliceItemAt(i int) S1Reader {
	if i < 0 || i >= v.FinalSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]S1]()
	var offset = structSizeOfTestGenericBlock + i*elemSize
	return S1Reader(v.SlabBytes()[offset:])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) SetFinalSliceItemAt(i int, x S1Reader) {
	if i < 0 || i >= v.FinalSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.FinalSliceLen(), v.FinalSliceCap()))
	}
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]S1]()
	var offset = structSizeOfTestGenericBlock + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x.SlabBytes()[:elemSize])
}

func (v TestGenericBlockWriter[T1, S1, S1Reader, S1Writer]) AppendFinalSliceItem(x S1Reader) {
	n := v.FinalSliceLen()
	if n == v.FinalSliceCap() {
		panic(fmt.Sprintf("append to slice overflows the maximum capacity [::%d]", v.FinalSliceCap()))
	}
	v.internalSetFinalSliceLen(n + 1)
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	var elemSize = slabutil.ElemSizeFor[[]S1]()
	var offset = structSizeOfTestGenericBlock + n*elemSize
	if x == nil {
		slabutil.SetZero(v.SlabBytes()[offset : offset+elemSize])
	} else {
		copy(v.SlabBytes()[offset:offset+elemSize], x.SlabBytes()[:elemSize])
	}
}

// NewTestGenericBlockReader creates a zero-initialized TestGenericBlock. Returns nil if input block size is too small.
func NewTestGenericBlock[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]](block []byte) TestGenericBlockReader[T1, S1, S1Reader, S1Writer] {
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	size := len(block)
	if size < structSizeOfTestGenericBlock {
		return nil
	}
	slabutil.SetZero(block)
	v := TestGenericBlockReader[T1, S1, S1Reader, S1Writer](block)
	// TestGenericBlock type has a slice field; we must set a cap on it.
	n := TestGenericBlockSliceFieldCap[T1, S1](size)
	v.Writer().internalSetFinalSliceCap(n)
	return v
}

// OpenTestGenericBlockReader parses and prepares an existing TestGenericBlock for read/write access.
func OpenTestGenericBlock[T1 slabs.Number, S1 slabs.Struct, S1Reader slabs.Reader[S1, S1Writer], S1Writer slabs.Writer[S1, S1Reader]](block []byte) (TestGenericBlockReader[T1, S1, S1Reader, S1Writer], error) {
	var structSizeOfTestGenericBlock = slabutil.SizeFor[input.TestGenericBlock[T1, S1]]()
	size := len(block)
	if size < structSizeOfTestGenericBlock {
		return nil, fmt.Errorf("input size is too small")
	}
	v := TestGenericBlockReader[T1, S1, S1Reader, S1Writer](block)
	// TestGenericBlock type has a slice field; validate it's len and cap.
	n := TestGenericBlockSliceFieldCap[T1, S1](size)
	if x := v.FinalSliceCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.FinalSliceLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
