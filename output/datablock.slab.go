// Code generated by github.com/visvasity/slabgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	input "github.com/visvasity/slabgen/input"
	"github.com/visvasity/slabgen/slabs"
	"github.com/visvasity/slabgen/slabutil"
	storage "github.com/visvasity/storage"
)

// Reader type defines accessor methods for read-only access.
type DataBlockReader[T slabs.Struct, TReader slabs.Reader[T, TWriter], TWriter slabs.Writer[T, TReader]] []byte

// Writer type extends the reader with mutable methods.
type DataBlockWriter[T slabs.Struct, TReader slabs.Reader[T, TWriter], TWriter slabs.Writer[T, TReader]] struct {
	DataBlockReader[T, TReader, TWriter]
}

var fieldOffsetsOfDataBlock slabutil.OffsetsMap

// SlabBytes returns access to the underlying byte slice.
func (v DataBlockReader[T, TReader, TWriter]) SlabBytes() slabs.Bytes {
	return []byte(v)
}

// Writer returns the DataBlock writer for read-write access to it's fields.
func (v DataBlockReader[T, TReader, TWriter]) Writer() DataBlockWriter[T, TReader, TWriter] {
	return DataBlockWriter[T, TReader, TWriter]{v}
}

// Reader returns the DataBlock reader with read-only access to it's fields.
func (v DataBlockWriter[T, TReader, TWriter]) Reader() DataBlockReader[T, TReader, TWriter] {
	return v.DataBlockReader
}

// IsZero returns true if all underlying bytes are zero.
func (v DataBlockReader[T, TReader, TWriter]) IsZero() bool {
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	return slabutil.IsZero(v[:structSizeOfDataBlock])
}

// SetZero sets all underlying bytes to zero.
func (v DataBlockWriter[T, TReader, TWriter]) SetZero() {
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	slabutil.SetZero(v.SlabBytes()[:structSizeOfDataBlock])
}

func (v DataBlockReader[T, TReader, TWriter]) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "NextLBA=%d", v.NextLBA())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ValuesSlice=[:%d:%d]{", v.ValuesSliceLen(), v.ValuesSliceCap())
	for i := 0; i < v.ValuesSliceLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ValuesSliceItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ValuesSliceItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v DataBlockReader[T, TReader, TWriter]) CopyTo(x *input.DataBlock[T]) {
	x.NextLBA = v.NextLBA()
	x.ValuesSlice = make([]T, v.ValuesSliceLen())
	for i := 0; i < v.ValuesSliceLen(); i++ {
		v.ValuesSliceItemAt(i).CopyTo(&x.ValuesSlice[i])
	}
}

func (v DataBlockWriter[T, TReader, TWriter]) CopyFrom(x *input.DataBlock[T]) {
	v.SetNextLBA(x.NextLBA)
	v.ResizeValuesSlice(len(x.ValuesSlice))
	for i := 0; i < len(x.ValuesSlice); i++ {
		v.ValuesSliceItemAt(i).Writer().CopyFrom(&x.ValuesSlice[i])
	}
}

func (v DataBlockReader[T, TReader, TWriter]) NextLBA() storage.LBA {
	var fieldOffsetsOfDataBlock = slabutil.OffsetsFor[input.DataBlock[T]](&fieldOffsetsOfDataBlock)
	var offset = fieldOffsetsOfDataBlock[0]
	return storage.LBA(v.SlabBytes().Uint64At(offset))
}

func (v DataBlockWriter[T, TReader, TWriter]) SetNextLBA(x storage.LBA) {
	var fieldOffsetsOfDataBlock = slabutil.OffsetsFor[input.DataBlock[T]](&fieldOffsetsOfDataBlock)
	var offset = fieldOffsetsOfDataBlock[0]
	v.SlabBytes().SetUint64At(offset, uint64(x))
}

// DataBlockSliceFieldCap returns the slice field capacity for the given underlying byte slice size.
func DataBlockSliceFieldCap[T slabs.Struct](nbytes int) int {
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	var sliceElemSizeOfDataBlock = slabutil.ElemSizeFor[T]()
	// TODO: We should also add the required alignment offset to the struct-size.
	return (nbytes - structSizeOfDataBlock) / sliceElemSizeOfDataBlock
}

// ValuesSliceLen method returns number of elements in the slice field.
func (v DataBlockReader[T, TReader, TWriter]) ValuesSliceLen() int {
	var fieldOffsetsOfDataBlock = slabutil.OffsetsFor[input.DataBlock[T]](&fieldOffsetsOfDataBlock)
	var offset = fieldOffsetsOfDataBlock[1] + slabutil.OffsetOfSliceLen
	return slabutil.IntAt(v.SlabBytes(), offset)
}

func (v DataBlockWriter[T, TReader, TWriter]) internalSetValuesSliceLen(x int) {
	var fieldOffsetsOfDataBlock = slabutil.OffsetsFor[input.DataBlock[T]](&fieldOffsetsOfDataBlock)
	var offset = fieldOffsetsOfDataBlock[1] + slabutil.OffsetOfSliceLen
	slabutil.SetIntAt(v.SlabBytes(), offset, x)
}

// ValuesSliceCap method returns maximum number of elements for the slice field.
func (v DataBlockReader[T, TReader, TWriter]) ValuesSliceCap() int {
	var fieldOffsetsOfDataBlock = slabutil.OffsetsFor[input.DataBlock[T]](&fieldOffsetsOfDataBlock)
	var offset = fieldOffsetsOfDataBlock[1] + slabutil.OffsetOfSliceCap
	return slabutil.IntAt(v.SlabBytes(), offset)
}

func (v DataBlockWriter[T, TReader, TWriter]) internalSetValuesSliceCap(x int) {
	var fieldOffsetsOfDataBlock = slabutil.OffsetsFor[input.DataBlock[T]](&fieldOffsetsOfDataBlock)
	var offset = fieldOffsetsOfDataBlock[1] + slabutil.OffsetOfSliceCap
	slabutil.SetIntAt(v.SlabBytes(), offset, x)
}

func (v DataBlockWriter[T, TReader, TWriter]) ResizeValuesSlice(size int) int {
	if cap := v.ValuesSliceCap(); size > cap {
		size = cap
	}
	n := v.ValuesSliceLen()
	if size == n {
		return size
	}
	if size < n {
		v.DeleteValuesSliceItems(size, n)
		return size
	}
	v.internalSetValuesSliceLen(size)
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	var elemSize = slabutil.ElemSizeFor[[]T]()
	var begin = structSizeOfDataBlock + n*elemSize
	var end = structSizeOfDataBlock + size*elemSize
	slabutil.SetZero(v.SlabBytes()[begin:end])
	return size
}

func (v DataBlockWriter[T, TReader, TWriter]) DeleteValuesSliceItems(i, j int) {
	n := v.ValuesSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("first slice index %d is out of range [0:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	if j < 0 || j >= n {
		panic(fmt.Sprintf("second slice index %d is out of range [0:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	if j < i {
		panic(fmt.Sprintf("invalid slice indices %d < %d", j, i))
	}
	if i == j {
		return
	}
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	var elemSize = slabutil.ElemSizeFor[[]T]()

	ioff := structSizeOfDataBlock + i*elemSize
	joff := structSizeOfDataBlock + j*elemSize
	end := structSizeOfDataBlock + n*elemSize

	copy(v.SlabBytes()[ioff:end], v.SlabBytes()[joff:end])
	slabutil.SetZero(v.SlabBytes()[end-(joff-ioff) : end])
	v.internalSetValuesSliceLen(n - (j - i))
}

func (v DataBlockReader[T, TReader, TWriter]) ValuesSliceItemAt(i int) TReader {
	if i < 0 || i >= v.ValuesSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	var elemSize = slabutil.ElemSizeFor[[]T]()
	var offset = structSizeOfDataBlock + i*elemSize
	return TReader(v.SlabBytes()[offset:])
}

func (v DataBlockWriter[T, TReader, TWriter]) SetValuesSliceItemAt(i int, x TReader) {
	if i < 0 || i >= v.ValuesSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	var elemSize = slabutil.ElemSizeFor[[]T]()
	var offset = structSizeOfDataBlock + i*elemSize
	copy(v.SlabBytes()[offset:offset+elemSize], x.SlabBytes()[:elemSize])
}

func (v DataBlockWriter[T, TReader, TWriter]) AppendValuesSliceItem(x TReader) {
	n := v.ValuesSliceLen()
	if n == v.ValuesSliceCap() {
		panic(fmt.Sprintf("append to slice overflows the maximum capacity [::%d]", v.ValuesSliceCap()))
	}
	v.internalSetValuesSliceLen(n + 1)
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	var elemSize = slabutil.ElemSizeFor[[]T]()
	var offset = structSizeOfDataBlock + n*elemSize
	if x == nil {
		slabutil.SetZero(v.SlabBytes()[offset : offset+elemSize])
	} else {
		copy(v.SlabBytes()[offset:offset+elemSize], x.SlabBytes()[:elemSize])
	}
}

// NewDataBlockReader creates a zero-initialized DataBlock. Returns nil if input block size is too small.
func NewDataBlock[T slabs.Struct, TReader slabs.Reader[T, TWriter], TWriter slabs.Writer[T, TReader]](block []byte) DataBlockReader[T, TReader, TWriter] {
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	size := len(block)
	if size < structSizeOfDataBlock {
		return nil
	}
	slabutil.SetZero(block)
	v := DataBlockReader[T, TReader, TWriter](block)
	// DataBlock type has a slice field; we must set a cap on it.
	n := DataBlockSliceFieldCap[T](size)
	v.Writer().internalSetValuesSliceCap(n)
	return v
}

// OpenDataBlockReader parses and prepares an existing DataBlock for read/write access.
func OpenDataBlock[T slabs.Struct, TReader slabs.Reader[T, TWriter], TWriter slabs.Writer[T, TReader]](block []byte) (DataBlockReader[T, TReader, TWriter], error) {
	var structSizeOfDataBlock = slabutil.SizeFor[input.DataBlock[T]]()
	size := len(block)
	if size < structSizeOfDataBlock {
		return nil, fmt.Errorf("input size is too small")
	}
	v := DataBlockReader[T, TReader, TWriter](block)
	// DataBlock type has a slice field; validate it's len and cap.
	n := DataBlockSliceFieldCap[T](size)
	if x := v.ValuesSliceCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.ValuesSliceLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
