// Code generated by github.com/visvasity/blockgen. DO NOT EDIT.

package output

import (
	"fmt"
	"strings"

	"github.com/visvasity/blockgen/blockgen"
	input "github.com/visvasity/blockgen/input"
)

// Reader type defines accessor methods for read-only access.
type SuperBlockReader blockgen.BlockBytes

// Writer type extends the reader with mutable methods.
type SuperBlockWriter struct{ SuperBlockReader }

var structSizeOfSuperBlock = blockgen.SizeFor[input.SuperBlock]()
var fieldOffsetsOfSuperBlock = blockgen.OffsetsFor[input.SuperBlock](nil)
var sliceDataAlignOfSuperBlock = blockgen.AlignFor[[]input.JournalRegion]()
var sliceElemSizeOfSuperBlock = blockgen.ElemSizeFor[[]input.JournalRegion]()

// BlockBytes returns access to the underlying byte slice.
func (v SuperBlockReader) BlockBytes() blockgen.BlockBytes {
	return blockgen.BlockBytes(v)
}

// Writer returns the SuperBlock writer for read-write access to it's fields.
func (v SuperBlockReader) Writer() SuperBlockWriter {
	return SuperBlockWriter{v}
}

// Reader returns the SuperBlock reader with read-only access to it's fields.
func (v SuperBlockWriter) Reader() SuperBlockReader {
	return v.SuperBlockReader
}

// IsZero returns true if all underlying bytes are zero.
func (v SuperBlockReader) IsZero() bool {
	return blockgen.IsZero(v[:structSizeOfSuperBlock])
}

// SetZero sets all underlying bytes to zero.
func (v SuperBlockWriter) SetZero() {
	blockgen.SetZero(v.BlockBytes()[:structSizeOfSuperBlock])
}

func (v SuperBlockReader) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "Header={%v}", v.Header())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "Options={%v}", v.Options())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "EndPBA=%d", v.EndPBA())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "MaxObjectID=%d", v.MaxObjectID())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "DBARegionList={%v}", v.DBARegionList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ObjectList={%v}", v.ObjectList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FreeDBAList={%v}", v.FreeDBAList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FreeDataRegionList={%v}", v.FreeDataRegionList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "SyncedCacheLSN=%d", v.SyncedCacheLSN())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalHeadOffset=%d", v.JournalHeadOffset())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalTailOffset=%d", v.JournalTailOffset())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalRegionSlice=[:%d:%d]{", v.JournalRegionSliceLen(), v.JournalRegionSliceCap())
	for i := 0; i < v.JournalRegionSliceLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.JournalRegionSliceItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.JournalRegionSliceItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v SuperBlockReader) CopyTo(x *input.SuperBlock) {
	v.Header().CopyTo(&x.Header)
	v.Options().CopyTo(&x.Options)
	x.EndPBA = v.EndPBA()
	x.MaxObjectID = v.MaxObjectID()
	v.DBARegionList().CopyTo(&x.DBARegionList)
	v.ObjectList().CopyTo(&x.ObjectList)
	v.FreeDBAList().CopyTo(&x.FreeDBAList)
	v.FreeDataRegionList().CopyTo(&x.FreeDataRegionList)
	x.SyncedCacheLSN = v.SyncedCacheLSN()
	x.JournalHeadOffset = v.JournalHeadOffset()
	x.JournalTailOffset = v.JournalTailOffset()
	x.JournalRegionSlice = make([]input.JournalRegion, v.JournalRegionSliceLen())
	for i := 0; i < v.JournalRegionSliceLen(); i++ {
		v.JournalRegionSliceItemAt(i).CopyTo(&x.JournalRegionSlice[i])
	}
}

func (v SuperBlockWriter) CopyFrom(x *input.SuperBlock) {
	v.Header().Writer().CopyFrom(&x.Header)
	v.Options().Writer().CopyFrom(&x.Options)
	v.SetEndPBA(x.EndPBA)
	v.SetMaxObjectID(x.MaxObjectID)
	v.DBARegionList().Writer().CopyFrom(&x.DBARegionList)
	v.ObjectList().Writer().CopyFrom(&x.ObjectList)
	v.FreeDBAList().Writer().CopyFrom(&x.FreeDBAList)
	v.FreeDataRegionList().Writer().CopyFrom(&x.FreeDataRegionList)
	v.SetSyncedCacheLSN(x.SyncedCacheLSN)
	v.SetJournalHeadOffset(x.JournalHeadOffset)
	v.SetJournalTailOffset(x.JournalTailOffset)
	v.ResizeJournalRegionSlice(len(x.JournalRegionSlice))
	for i := 0; i < len(x.JournalRegionSlice); i++ {
		v.JournalRegionSliceItemAt(i).Writer().CopyFrom(&x.JournalRegionSlice[i])
	}
}

func (v SuperBlockReader) Header() BlockHeaderReader {
	var offset = fieldOffsetsOfSuperBlock[0]
	return BlockHeaderReader(v.BlockBytes()[offset:])
}

func (v SuperBlockReader) Options() StorageOptionsReader {
	var offset = fieldOffsetsOfSuperBlock[1]
	return StorageOptionsReader(v.BlockBytes()[offset:])
}

func (v SuperBlockReader) EndPBA() input.PBA {
	var offset = fieldOffsetsOfSuperBlock[2]
	return input.PBA(v.BlockBytes().Uint64At(offset))
}

func (v SuperBlockWriter) SetEndPBA(x input.PBA) {
	var offset = fieldOffsetsOfSuperBlock[2]
	v.BlockBytes().SetUint64At(offset, uint64(x))
}

func (v SuperBlockReader) MaxObjectID() input.ObjectID {
	var offset = fieldOffsetsOfSuperBlock[3]
	return input.ObjectID(v.BlockBytes().Int64At(offset))
}

func (v SuperBlockWriter) SetMaxObjectID(x input.ObjectID) {
	var offset = fieldOffsetsOfSuperBlock[3]
	v.BlockBytes().SetInt64At(offset, int64(x))
}

func (v SuperBlockReader) DBARegionList() LinkedListReader {
	var offset = fieldOffsetsOfSuperBlock[4]
	return LinkedListReader(v.BlockBytes()[offset:])
}

func (v SuperBlockReader) ObjectList() LinkedListReader {
	var offset = fieldOffsetsOfSuperBlock[5]
	return LinkedListReader(v.BlockBytes()[offset:])
}

func (v SuperBlockReader) FreeDBAList() LinkedListReader {
	var offset = fieldOffsetsOfSuperBlock[6]
	return LinkedListReader(v.BlockBytes()[offset:])
}

func (v SuperBlockReader) FreeDataRegionList() LinkedListReader {
	var offset = fieldOffsetsOfSuperBlock[7]
	return LinkedListReader(v.BlockBytes()[offset:])
}

func (v SuperBlockReader) SyncedCacheLSN() input.LSN {
	var offset = fieldOffsetsOfSuperBlock[8]
	return input.LSN(v.BlockBytes().Int64At(offset))
}

func (v SuperBlockWriter) SetSyncedCacheLSN(x input.LSN) {
	var offset = fieldOffsetsOfSuperBlock[8]
	v.BlockBytes().SetInt64At(offset, int64(x))
}

func (v SuperBlockReader) JournalHeadOffset() int64 {
	var offset = fieldOffsetsOfSuperBlock[9]
	return int64(v.BlockBytes().Int64At(offset))
}

func (v SuperBlockWriter) SetJournalHeadOffset(x int64) {
	var offset = fieldOffsetsOfSuperBlock[9]
	v.BlockBytes().SetInt64At(offset, int64(x))
}

func (v SuperBlockReader) JournalTailOffset() int64 {
	var offset = fieldOffsetsOfSuperBlock[10]
	return int64(v.BlockBytes().Int64At(offset))
}

func (v SuperBlockWriter) SetJournalTailOffset(x int64) {
	var offset = fieldOffsetsOfSuperBlock[10]
	v.BlockBytes().SetInt64At(offset, int64(x))
}

// SuperBlockSliceFieldCap returns the slice field capacity for the given underlying byte slice size.
func SuperBlockSliceFieldCap(nbytes int) int {
	// TODO: We should also add the required alignment offset to the struct-size.
	return (nbytes - structSizeOfSuperBlock) / sliceElemSizeOfSuperBlock
}

// JournalRegionSliceLen method returns number of elements in the slice field.
func (v SuperBlockReader) JournalRegionSliceLen() int {
	var offset = fieldOffsetsOfSuperBlock[11] + blockgen.OffsetOfSliceLen
	return blockgen.IntAt(v.BlockBytes(), offset)
}

func (v SuperBlockWriter) internalSetJournalRegionSliceLen(x int) {
	var offset = fieldOffsetsOfSuperBlock[11] + blockgen.OffsetOfSliceLen
	blockgen.SetIntAt(v.BlockBytes(), offset, x)
}

// JournalRegionSliceCap method returns maximum number of elements for the slice field.
func (v SuperBlockReader) JournalRegionSliceCap() int {
	var offset = fieldOffsetsOfSuperBlock[11] + blockgen.OffsetOfSliceCap
	return blockgen.IntAt(v.BlockBytes(), offset)
}

func (v SuperBlockWriter) internalSetJournalRegionSliceCap(x int) {
	var offset = fieldOffsetsOfSuperBlock[11] + blockgen.OffsetOfSliceCap
	blockgen.SetIntAt(v.BlockBytes(), offset, x)
}

func (v SuperBlockWriter) ResizeJournalRegionSlice(size int) int {
	if cap := v.JournalRegionSliceCap(); size > cap {
		size = cap
	}
	n := v.JournalRegionSliceLen()
	if size == n {
		return size
	}
	if size < n {
		v.DeleteJournalRegionSliceItems(size, n)
		return size
	}
	v.internalSetJournalRegionSliceLen(size)
	var elemSize = blockgen.ElemSizeFor[[]input.JournalRegion]()
	var begin = structSizeOfSuperBlock + n*elemSize
	var end = structSizeOfSuperBlock + size*elemSize
	blockgen.SetZero(v.BlockBytes()[begin:end])
	return size
}

func (v SuperBlockWriter) DeleteJournalRegionSliceItems(i, j int) {
	n := v.JournalRegionSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("first slice index %d is out of range [0:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	if j < 0 || j >= n {
		panic(fmt.Sprintf("second slice index %d is out of range [0:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	if j < i {
		panic(fmt.Sprintf("invalid slice indices %d < %d", j, i))
	}
	if i == j {
		return
	}
	var elemSize = blockgen.ElemSizeFor[[]input.JournalRegion]()

	ioff := structSizeOfSuperBlock + i*elemSize
	joff := structSizeOfSuperBlock + j*elemSize
	end := structSizeOfSuperBlock + n*elemSize

	copy(v.BlockBytes()[ioff:end], v.BlockBytes()[joff:end])
	blockgen.SetZero(v.BlockBytes()[end-(joff-ioff) : end])
	v.internalSetJournalRegionSliceLen(n - (j - i))
}

func (v SuperBlockReader) JournalRegionSliceItemAt(i int) JournalRegionReader {
	if i < 0 || i >= v.JournalRegionSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	var elemSize = blockgen.ElemSizeFor[[]input.JournalRegion]()
	var offset = structSizeOfSuperBlock + i*elemSize
	return JournalRegionReader(v.BlockBytes()[offset:])
}

func (v SuperBlockWriter) SetJournalRegionSliceItemAt(i int, x JournalRegionReader) {
	if i < 0 || i >= v.JournalRegionSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	var elemSize = blockgen.ElemSizeFor[[]input.JournalRegion]()
	var offset = structSizeOfSuperBlock + i*elemSize
	copy(v.BlockBytes()[offset:offset+elemSize], x.BlockBytes()[:elemSize])
}

func (v SuperBlockWriter) AppendJournalRegionSliceItem(x JournalRegionReader) {
	n := v.JournalRegionSliceLen()
	if n == v.JournalRegionSliceCap() {
		panic(fmt.Sprintf("append to slice overflows the maximum capacity [::%d]", v.JournalRegionSliceCap()))
	}
	v.internalSetJournalRegionSliceLen(n + 1)
	var elemSize = blockgen.ElemSizeFor[[]input.JournalRegion]()
	var offset = structSizeOfSuperBlock + n*elemSize
	if x == nil {
		blockgen.SetZero(v.BlockBytes()[offset : offset+elemSize])
	} else {
		copy(v.BlockBytes()[offset:offset+elemSize], x.BlockBytes()[:elemSize])
	}
}

// NewSuperBlockReader creates a zero-initialized SuperBlock. Returns nil if input block size is too small.
func NewSuperBlock(block []byte) SuperBlockReader {
	size := len(block)
	if size < structSizeOfSuperBlock {
		return nil
	}
	blockgen.SetZero(block)
	v := SuperBlockReader(block)
	// SuperBlock type has a slice field; we must set a cap on it.
	n := SuperBlockSliceFieldCap(size)
	v.Writer().internalSetJournalRegionSliceCap(n)
	return v
}

// OpenSuperBlockReader parses and prepares an existing SuperBlock for read/write access.
func OpenSuperBlock(block []byte) (SuperBlockReader, error) {
	size := len(block)
	if size < structSizeOfSuperBlock {
		return nil, fmt.Errorf("input size is too small")
	}
	v := SuperBlockReader(block)
	// SuperBlock type has a slice field; validate it's len and cap.
	n := SuperBlockSliceFieldCap(size)
	if x := v.JournalRegionSliceCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.JournalRegionSliceLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
